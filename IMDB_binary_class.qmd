---
title: "IMDB_binary_classification"
format: html
editor: visual
---

## IMDB Binary Classification

The IMDB dataset from Keras comes with 50,000 polarized views (positive or negative). The test/train split is 50/50 and the data has already been preprocessed (reviews are a list of integers). The ratio of positive and negative reviews are split evenly in each of the datasets,

#### Packages

```{r}
library(keras)
```

#### Load the IMDB dataset

```{r}
imdb <- dataset_imdb(num_words = 10000)
c(c(train_data, train_labels), c(test_data, test_labels)) %<-% imdb
```

-   Note: If you get an error about the SSL certificate failing, you can likely fix the issue by running the `install Certficate.command` file in the python application folder. More info [here](https://bugs.python.org/issue28150)

-   The label lists ositive reviews are 1 and negative reviews are 0

When loading the data, we used `%<-%` which is the multi-assignment operator from the `zeallot` package.

-   This unpacks a list into a set of distinct variables but could also be written as

```{r, eval = FALSE}
imdb <- dataset_imdb(num_words = 10000)
train_data <- imdb$train$x
train_labels <- imdb$train$y
test_data <- imdb$test$x
test_labels <- imdb$test$y
```

Inspecting the data and labels:

```{r}
str(train_data[[1]])
train_labels[[1]]
```

If we wanted to transform the reviews back into English, we can use the following for the first review:

```{r}
# named list that maps words to an integer index
word_index <- dataset_imdb_word_index()
# Maps integer index to words
reverse_word_index <- names(word_index)

# Decodes the review
names(reverse_word_index) <- word_index
decoded_review <- sapply(train_data[[1]], function(index){
  word <- if (index >= 3) reverse_word_index[[as.character(index - 3)]]
  if (!is.null(word)) word
  else "?"
})
```

-   The review is offset by 3 because 0, 1, and 2 are reserved indices for "padding", "start of sequence" and "unknown"

## Preparing the data

We need to transform the lists into tensors, which can be done by one-hot encoding the list. Here, we'll encode the integer sequences into a binary matrix

```{r}
# Function to create matrix of shape (length(sequence), dimensions) with all zeros
vectorize_sequences <- function(sequences, dimension = 10000){
  results <- matrix(0, nrow = length(sequences), ncol = dimension)
  # Set specific indicies of results[i] to 1
  for (i in 1:length(sequences))
    results[i, sequences[[i]]] <- 1
  results
}

x_train <- vectorize_sequences(train_data)
x_test <- vectorize_sequences(test_data)

# Convert labels from numeric to integers
y_train <- as.numeric(train_labels)
y_test <- as.numeric(test_labels)
```

```{}
```
